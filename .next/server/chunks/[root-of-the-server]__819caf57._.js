module.exports = {

"[project]/.next-internal/server/app/api/fetched-resources/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/stream [external] (stream, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}}),
"[externals]/path [external] (path, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/fs [external] (fs, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/tty [external] (tty, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}}),
"[externals]/os [external] (os, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[project]/app/api/fetched-resources/route.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pages/api/youtube-course-finder.js
__turbopack_context__.s({
    "config": (()=>config),
    "default": (()=>handler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/generative-ai/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/axios/lib/axios.js [app-route] (ecmascript)");
;
;
// Initialize Gemini client
const genAI = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$generative$2d$ai$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleGenerativeAI"](process.env.GEMINI_API_KEY);
// YouTube Data API configuration
const YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY;
const YOUTUBE_API_BASE = 'https://www.googleapis.com/youtube/v3';
// Cache for reducing API calls (optional, use Redis in production)
const cache = new Map();
const CACHE_TTL = 3600000; // 1 hour
/**
 * Validate environment variables
 */ function validateEnv() {
    const errors = [];
    if (!process.env.YOUTUBE_API_KEY) {
        errors.push('YOUTUBE_API_KEY is not configured');
    }
    if (!process.env.GEMINI_API_KEY) {
        errors.push('GEMINI_API_KEY is not configured');
    }
    return errors;
}
/**
 * Fetch YouTube videos based on search query
 */ async function fetchYouTubeVideos(query, language = 'en', maxResults = 10) {
    const cacheKey = `${query}-${language}-${maxResults}`;
    // Check cache
    if (cache.has(cacheKey)) {
        const cached = cache.get(cacheKey);
        if (Date.now() - cached.timestamp < CACHE_TTL) {
            console.log('Returning cached results');
            return cached.data;
        }
        cache.delete(cacheKey);
    }
    try {
        // Step 1: Search for videos
        const searchResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${YOUTUBE_API_BASE}/search`, {
            params: {
                part: 'snippet',
                q: query,
                type: 'video',
                maxResults: maxResults,
                relevanceLanguage: language,
                videoDuration: 'medium',
                videoDefinition: 'high',
                safeSearch: 'strict',
                key: YOUTUBE_API_KEY
            },
            timeout: 10000
        });
        const videos = searchResponse.data.items || [];
        if (videos.length === 0) {
            return [];
        }
        const videoIds = videos.map((v)=>v.id.videoId).join(',');
        // Step 2: Fetch detailed video information
        const detailsResponse = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$axios$2f$lib$2f$axios$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].get(`${YOUTUBE_API_BASE}/videos`, {
            params: {
                part: 'snippet,contentDetails,statistics',
                id: videoIds,
                key: YOUTUBE_API_KEY
            },
            timeout: 10000
        });
        // Step 3: Process and enrich video data
        const enrichedVideos = detailsResponse.data.items.map((video)=>{
            // Parse ISO 8601 duration (PT15M33S -> 15:33)
            const duration = parseDuration(video.contentDetails.duration);
            return {
                video_id: video.id,
                title: video.snippet.title,
                description: video.snippet.description,
                thumbnail: video.snippet.thumbnails.high?.url || video.snippet.thumbnails.medium?.url || video.snippet.thumbnails.default.url,
                channel: video.snippet.channelTitle,
                channel_id: video.snippet.channelId,
                publish_date: video.snippet.publishedAt.split('T')[0],
                duration: duration,
                view_count: parseInt(video.statistics.viewCount) || 0,
                like_count: parseInt(video.statistics.likeCount) || 0,
                comment_count: parseInt(video.statistics.commentCount) || 0,
                url: `https://www.youtube.com/watch?v=${video.id}`
            };
        });
        // Sort by relevance (views + likes)
        enrichedVideos.sort((a, b)=>{
            const scoreA = a.view_count + a.like_count * 10;
            const scoreB = b.view_count + b.like_count * 10;
            return scoreB - scoreA;
        });
        // Cache results
        cache.set(cacheKey, {
            data: enrichedVideos,
            timestamp: Date.now()
        });
        return enrichedVideos;
    } catch (error) {
        console.error('Error fetching YouTube videos:', error.response?.data || error.message);
        if (error.response?.status === 403) {
            throw new Error('YouTube API quota exceeded or invalid API key');
        }
        if (error.code === 'ECONNABORTED') {
            throw new Error('Request timeout - please try again');
        }
        throw new Error('Failed to fetch YouTube videos');
    }
}
/**
 * Parse ISO 8601 duration to readable format
 */ function parseDuration(isoDuration) {
    const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 'Unknown';
    const hours = match[1] ? parseInt(match[1]) : 0;
    const minutes = match[2] ? parseInt(match[2]) : 0;
    const seconds = match[3] ? parseInt(match[3]) : 0;
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}
/**
 * Generate AI response using Gemini 2.0
 */ async function generateCourseAnalysis(userQuery, language, youtubeData) {
    const systemPrompt = `You are an intelligent AI YouTube Course Resource Finder.  
You receive the user's learning request and a list of relevant YouTube videos (fetched using YouTube Data API).  
Your task is to analyze the videos and generate an informative, structured response showing only the best and most relevant resources.

### Your Goals:
1. Understand exactly what the user wants to learn from their query.
2. Select the most relevant and high-quality YouTube videos from the provided list.
3. For each selected video, generate:
   - Course Title (from the video title)
   - Short Description (based on description)
   - Key Learning Points (3–5 bullets)
   - Thumbnail URL
   - Channel Name
   - Publish Date
   - Duration
   - Estimated Level (Beginner / Intermediate / Advanced based on content)
4. At the end, generate a **Course Summary Section**:
   - Explain how these videos connect as a full course or learning path.
   - Suggest a few "Next Step Topics" the user can explore after completing the videos.

### Output Format (HTML)
Return clean, readable HTML with:
- <h2> for main course title
- <h3> for each video title with video number
- <p> for short summaries
- <ul><li> for learning points
- Include thumbnail as <img src="..." alt="..." width="300" style="border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"/>
- Include video link as <a href="{video_url}" target="_blank" rel="noopener" style="color: #4f46e5; font-weight: 600; text-decoration: none;">Watch Video →</a>
- Show channel name, publish date, duration, and level as: <p style="color: #6b7280; font-size: 0.9em;"><strong>Channel:</strong> TechCourse | <strong>Published:</strong> 2024-05-10 | <strong>Duration:</strong> 15:30 | <strong>Level:</strong> Beginner</p>
- At the end, <h3>📚 Course Summary</h3> explaining the learning path
- Then <h3>🚀 Next Topics</h3> with bullet list of recommended next steps

### Notes:
- Always use the language requested by the user for ALL content.
- Ignore unrelated or duplicate videos.
- Focus on educational and course-style content.
- Do not include promotional or clickbait content.
- Select ONLY the top 5-7 most relevant videos.
- Arrange videos in a logical learning order (beginner to advanced).
- Be concise but informative in descriptions.`;
    const userMessage = `User Query: "${userQuery}"
Language: ${language}
YouTube Videos Data:
${JSON.stringify(youtubeData, null, 2)}

Please analyze these videos and create a structured learning path with HTML formatting as specified.`;
    try {
        // Use Gemini 2.0 Flash model
        const model = genAI.getGenerativeModel({
            model: 'gemini-2.0-flash-exp',
            systemInstruction: systemPrompt,
            generationConfig: {
                temperature: 0.7,
                topP: 0.9,
                topK: 40,
                maxOutputTokens: 4096
            },
            safetySettings: [
                {
                    category: 'HARM_CATEGORY_HARASSMENT',
                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                },
                {
                    category: 'HARM_CATEGORY_HATE_SPEECH',
                    threshold: 'BLOCK_MEDIUM_AND_ABOVE'
                }
            ]
        });
        const result = await model.generateContent(userMessage);
        const response = await result.response;
        const htmlContent = response.text();
        // Clean up the HTML (remove markdown code blocks if present)
        let cleanedHtml = htmlContent.trim();
        if (cleanedHtml.startsWith('```html')) {
            cleanedHtml = cleanedHtml.replace(/```html\n?/, '').replace(/```\n?$/, '');
        } else if (cleanedHtml.startsWith('```')) {
            cleanedHtml = cleanedHtml.replace(/```\n?/, '').replace(/```\n?$/, '');
        }
        return cleanedHtml.trim();
    } catch (error) {
        console.error('Error calling Gemini API:', error);
        if (error.message?.includes('quota')) {
            throw new Error('Gemini API quota exceeded. Please try again later.');
        }
        if (error.message?.includes('API key')) {
            throw new Error('Invalid Gemini API key configuration');
        }
        throw new Error('Failed to generate AI response: ' + error.message);
    }
}
/**
 * Rate limiting helper (simple in-memory, use Redis in production)
 */ const rateLimitMap = new Map();
const RATE_LIMIT_WINDOW = 60000; // 1 minute
const RATE_LIMIT_MAX_REQUESTS = 10;
function checkRateLimit(identifier) {
    const now = Date.now();
    const userRequests = rateLimitMap.get(identifier) || [];
    // Remove old requests outside the window
    const recentRequests = userRequests.filter((time)=>now - time < RATE_LIMIT_WINDOW);
    if (recentRequests.length >= RATE_LIMIT_MAX_REQUESTS) {
        return false;
    }
    recentRequests.push(now);
    rateLimitMap.set(identifier, recentRequests);
    return true;
}
async function handler(req, res) {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    // Handle preflight request
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    // Only allow POST requests
    if (req.method !== 'POST') {
        return res.status(405).json({
            error: 'Method not allowed',
            message: 'This endpoint only accepts POST requests'
        });
    }
    try {
        // Validate environment variables
        const envErrors = validateEnv();
        if (envErrors.length > 0) {
            console.error('Environment configuration errors:', envErrors);
            return res.status(500).json({
                error: 'Server configuration error',
                message: 'API keys are not properly configured. Please contact the administrator.'
            });
        }
        // Parse and validate request body
        const { query, language = 'en', maxResults = 10 } = req.body;
        if (!query || typeof query !== 'string') {
            return res.status(400).json({
                error: 'Invalid request',
                message: 'Query parameter is required and must be a string'
            });
        }
        if (query.trim().length < 2) {
            return res.status(400).json({
                error: 'Invalid request',
                message: 'Query must be at least 2 characters long'
            });
        }
        if (query.length > 200) {
            return res.status(400).json({
                error: 'Invalid request',
                message: 'Query must be less than 200 characters'
            });
        }
        // Validate maxResults
        const validMaxResults = Math.min(Math.max(parseInt(maxResults) || 10, 1), 20);
        // Rate limiting (use IP or user ID in production)
        const identifier = req.headers['x-forwarded-for'] || req.socket.remoteAddress || 'unknown';
        if (!checkRateLimit(identifier)) {
            return res.status(429).json({
                error: 'Too many requests',
                message: 'Rate limit exceeded. Please try again in a minute.'
            });
        }
        console.log(`Processing request: "${query}" (lang: ${language}, max: ${validMaxResults})`);
        // Step 1: Fetch YouTube videos
        const youtubeVideos = await fetchYouTubeVideos(query.trim(), language, validMaxResults);
        if (!youtubeVideos || youtubeVideos.length === 0) {
            return res.status(404).json({
                error: 'No videos found',
                message: 'No relevant YouTube videos found for your query. Try different keywords or check your spelling.'
            });
        }
        console.log(`Found ${youtubeVideos.length} videos. Generating AI analysis...`);
        // Step 2: Generate AI analysis with Gemini
        const aiResponse = await generateCourseAnalysis(query.trim(), language, youtubeVideos);
        // Step 3: Return successful response
        return res.status(200).json({
            success: true,
            query: query.trim(),
            language: language,
            total_videos_found: youtubeVideos.length,
            html_content: aiResponse,
            raw_videos: youtubeVideos,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('API Error:', error);
        // Return appropriate error response
        const statusCode = error.message?.includes('quota') ? 503 : error.message?.includes('timeout') ? 504 : 500;
        return res.status(statusCode).json({
            error: 'Internal server error',
            message: error.message || 'An unexpected error occurred. Please try again.'
        });
    }
}
const config = {
    api: {
        bodyParser: {
            sizeLimit: '1mb'
        },
        responseLimit: '8mb'
    }
};
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__819caf57._.js.map